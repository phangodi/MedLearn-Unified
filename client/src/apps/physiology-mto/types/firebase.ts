import { Timestamp } from 'firebase/firestore';

/**
 * Firebase Types for MTO Questions System
 *
 * This file defines all TypeScript interfaces for the MTO Questions
 * collections in Firestore. These types ensure type safety across
 * the application when working with Firebase data.
 */

// ============================================================================
// MAIN QUESTION TYPES
// ============================================================================

/**
 * Main question interface for Firestore mtoQuestions collection
 *
 * Each document represents a single multiple-choice question.
 * Document IDs are auto-generated by Firestore.
 */
export interface MTOQuestion {
  // Question content
  text: string;
  textNormalized: string;  // Lowercase, stripped punctuation for duplicate detection
  correctAnswerCount: number;
  options: QuestionOption[];
  correctAnswers: string[];  // ["a", "c"]

  // PRIMARY ORGANIZATION
  // These are THE source of truth for where this question appears
  topics: number[];  // [33, 40] - Topic IDs this question belongs to
  mcqs: string[];    // ["mcq-3"] - MCQ sets (derived from topics)

  // TEST ID (optional - for future filtering by exam/test)
  testId?: string;

  // Duplicate detection
  contentHash: string;  // MD5 hash of normalized question+options

  // Status
  status: 'active' | 'archived' | 'draft';

  // Audit trail
  createdAt: Timestamp;
  createdBy: string;  // User ID
  updatedAt: Timestamp;
  updatedBy: string;  // User ID

  // Legacy reference (preserved from JSON import)
  legacyId?: string;

  // Quality metadata
  matchedBy: 'ai-verified' | 'manual' | 'imported';
  matchConfidence: number;  // 0.0 to 1.0
  matchReason?: string;
}

/**
 * Question option (answer choice)
 */
export interface QuestionOption {
  letter: string;  // "a", "b", "c", "d", "e"
  text: string;
}

// ============================================================================
// EXPLANATION TYPES
// ============================================================================

/**
 * AI-generated or human-written explanation for a question
 *
 * Stored in questionExplanations collection.
 * One explanation per question (questionId is the document ID).
 */
export interface QuestionExplanation {
  questionId: string;  // References mtoQuestions document ID
  correctLetters: string[];  // ["a", "c"]

  // Explanation content
  summary: string;  // Brief overview
  whyCorrect: Record<string, string>;  // { "a": "reason", "c": "reason" }
  whyIncorrect: Record<string, string>;  // { "b": "reason", "d": "reason" }
  topicReference: string;  // Link to relevant topic content

  // Metadata
  generatedAt: Timestamp;
  sourceTopics: number[];  // Topics used to generate explanation
  needsReview: boolean;
  reviewReason?: string;
}

// ============================================================================
// FLAG/REPORT TYPES
// ============================================================================

/**
 * User-reported issues with a question
 *
 * Stored in questionFlags collection.
 * Document ID = questionId
 */
export interface QuestionFlag {
  questionId: string;  // References mtoQuestions document ID
  flagCount: number;  // Total number of flags
  flaggedBy: string[];  // User IDs who flagged

  // Flag reasons breakdown
  flagReasons: {
    wrongTopic: number;
    incorrectAnswer: number;
    unclearQuestion: number;
    other: number;
  };

  // Resolution
  resolved: boolean;
  resolvedAt?: Timestamp;
  resolvedBy?: string;  // User ID
}

// ============================================================================
// AUDIT LOG TYPES
// ============================================================================

/**
 * Audit log entry for tracking all changes
 *
 * Stored in auditLog collection.
 * Document IDs are auto-generated.
 */
export interface AuditLogEntry {
  timestamp: Timestamp;
  userId: string;
  userEmail: string;
  action: 'create' | 'update' | 'delete' | 'archive' | 'generate_explanation';
  targetCollection: 'mtoQuestions' | 'questionExplanations' | 'questionFlags';
  targetId: string;  // Document ID in target collection

  // Detailed change tracking (optional)
  changes?: {
    field: string;
    oldValue: unknown;
    newValue: unknown;
  }[];

  // Additional context (optional)
  metadata?: Record<string, unknown>;
}

// ============================================================================
// SYSTEM STATS TYPES
// ============================================================================

/**
 * System-wide statistics for the questions database
 *
 * Stored as a single document: systemStats/current
 * Updated periodically or on-demand.
 */
export interface SystemStats {
  totalQuestions: number;
  questionsByTopic: Record<number, number>;  // { 33: 45, 40: 32, ... }
  questionsByMcq: Record<string, number>;    // { "mcq-1": 120, "mcq-2": 95, ... }
  questionsWithExplanations: number;
  questionsNeedingReview: number;
  totalFlags: number;
  unresolvedFlags: number;
  lastUpdated: Timestamp;
}

// ============================================================================
// HELPER TYPES
// ============================================================================

/**
 * Legacy question format from JSON files
 * Used during migration only
 */
export interface LegacyQuestion {
  id: string;
  testId: string;
  questionNumber: number;
  text: string;
  correctAnswerCount: number;
  options: QuestionOption[];
  correctAnswers: string[];
  topics: number[];
  mcqs: string[];
  metadata?: {
    importedAt?: string;
    matchedBy?: 'ai-verified' | 'manual' | 'imported';
    matchConfidence?: number;
    matchReason?: string;
  };
}

/**
 * Batch write operation for Firestore
 */
export interface BatchOperation {
  collection: string;
  docId?: string;  // Optional: let Firestore auto-generate
  data: Partial<MTOQuestion | QuestionExplanation | QuestionFlag | AuditLogEntry | SystemStats>;
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Normalize text for duplicate detection
 *
 * Converts text to lowercase, removes punctuation, extra whitespace.
 * Used to generate textNormalized field and for comparison.
 *
 * @param text - The text to normalize
 * @returns Normalized text string
 *
 * @example
 * normalizeText("In the systemic circulation, what happens?")
 * // Returns: "in the systemic circulation what happens"
 */
export function normalizeText(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s]/g, '') // Remove punctuation
    .replace(/\s+/g, ' ')    // Collapse multiple spaces
    .trim();
}

/**
 * Generate content hash for duplicate detection
 *
 * Creates an MD5 hash from normalized question text + all option texts.
 * Used to detect duplicate questions even if wording differs slightly.
 *
 * @param text - Question text
 * @param options - Question options
 * @returns MD5 hash string
 */
export function generateContentHash(text: string, options: QuestionOption[]): string {
  const crypto = require('crypto');

  // Normalize question text
  const normalizedText = normalizeText(text);

  // Normalize all option texts and concatenate
  const normalizedOptions = options
    .map(opt => normalizeText(opt.text))
    .sort() // Sort to handle option order changes
    .join('|');

  // Combine and hash
  const content = `${normalizedText}|||${normalizedOptions}`;
  return crypto.createHash('md5').update(content).digest('hex');
}

/**
 * Convert legacy question to MTOQuestion format
 *
 * Transforms a JSON file question into Firestore-ready format.
 * Used during migration.
 *
 * @param legacyQuestion - Question from JSON file
 * @param userId - ID of user performing the migration
 * @returns MTOQuestion ready for Firestore
 */
export function convertLegacyToMTOQuestion(
  legacyQuestion: LegacyQuestion,
  userId: string = 'system'
): Omit<MTOQuestion, 'createdAt' | 'updatedAt'> {
  const now = Timestamp.now();

  return {
    text: legacyQuestion.text,
    textNormalized: normalizeText(legacyQuestion.text),
    correctAnswerCount: legacyQuestion.correctAnswerCount,
    options: legacyQuestion.options,
    correctAnswers: legacyQuestion.correctAnswers,
    topics: legacyQuestion.topics,
    mcqs: legacyQuestion.mcqs,
    testId: legacyQuestion.testId,
    contentHash: generateContentHash(legacyQuestion.text, legacyQuestion.options),
    status: 'active',
    createdBy: userId,
    updatedBy: userId,
    legacyId: legacyQuestion.id,
    matchedBy: legacyQuestion.metadata?.matchedBy || 'imported',
    matchConfidence: legacyQuestion.metadata?.matchConfidence || 0.5,
    matchReason: legacyQuestion.metadata?.matchReason,
  };
}

// ============================================================================
// TYPE GUARDS
// ============================================================================

/**
 * Type guard to check if an object is a valid MTOQuestion
 */
export function isMTOQuestion(obj: unknown): obj is MTOQuestion {
  if (typeof obj !== 'object' || obj === null) return false;

  const q = obj as Partial<MTOQuestion>;

  return (
    typeof q.text === 'string' &&
    typeof q.textNormalized === 'string' &&
    typeof q.correctAnswerCount === 'number' &&
    Array.isArray(q.options) &&
    Array.isArray(q.correctAnswers) &&
    Array.isArray(q.topics) &&
    Array.isArray(q.mcqs) &&
    typeof q.contentHash === 'string' &&
    (q.status === 'active' || q.status === 'archived' || q.status === 'draft')
  );
}

/**
 * Type guard to check if an object is a valid QuestionExplanation
 */
export function isQuestionExplanation(obj: unknown): obj is QuestionExplanation {
  if (typeof obj !== 'object' || obj === null) return false;

  const e = obj as Partial<QuestionExplanation>;

  return (
    typeof e.questionId === 'string' &&
    Array.isArray(e.correctLetters) &&
    typeof e.summary === 'string' &&
    typeof e.whyCorrect === 'object' &&
    typeof e.whyIncorrect === 'object' &&
    typeof e.needsReview === 'boolean'
  );
}
